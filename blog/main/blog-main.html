<div class="page-header">
    <div class="page-header-inner">
        <div class="page-header-inner2">
            <h1>Blog</h1>
        </div>
    </div>
</div>
<div class="recent-post">

    <div class="post-1">
        <div class="recent-post-header">
            <h1 data-target="browser-chrome_browser_architecture">Chrome Browser Architecture</h1>
            <h3>November 2021</h3>
        </div>
        <div class="paragraph">
            <p>
                This is the first part of a series on the chrome browser and its javascript engine v8. In this part I will start by covering general information about chrome's browser architecture, how v8 fits in and its general compilation pipeline to execute javascript code. Finally we will setup a suitable debugging environment and look at a small js program in the debugger. <br><br> 
                My goal with this series is to make browser exploitation a little more accessible and to provide a strong baseline for anyone interested in getting started with this topic.
            </p>
            <img src="../imgs/browser/chrome_arch/logo.jpg" width="200" height="200" alt="">
        </div>
    </div>

    <div class="post-2">
        <div class="recent-post-header">
            <h1 data-target="kernel-return_oriented_programming">Kernel Return Oriented Programming</h1>
            <h3>September 2021</h3>
        </div>
        <div class="paragraph">
            <p>
                In this post I will cover the basics of return oriented programming in kernel land. Many of the overarching concepts are similar to usermode return oriented programming, however there are also some major differences. I will be demonstrating these concepts against an intentionally vulnerable kernel module on kernel version 5.8. The following mitigations will be enabled for this exploit: kcanary, smep, smap, kpti and kaslr.
            </p>
            <img src="../imgs/kernel/s_driver/logo.png" width="200" height="200" alt="">
        </div>
    </div>

    <div class="post-3">
        <div class="recent-post-header">
            <h1 data-target="kernel-char_driver_part_1">Linux Character Device Driver Part 1</h1>
            <h3>August 2021</h3>
        </div>
        <div class="paragraph">
            <p>
                This will be the first post in a series focused on writing a linux character device driver. This post covers the basics of initializing a driver and implementing simple open/release/read/write functions. Kernel modules are used to extend the kernel's functionality to support different devices and non-standard operations. This series will assume no prerequisite knowledge and cover the creation of a linux kernel module starting from the very beginning.
            </p>
            <img src="../imgs/kernel/s_driver/logo.png" width="200" height="200" alt="">
        </div>
    </div>

    <div class="post-4">
        <div class="recent-post-header">
            <h1 data-target="game-minesweeper">Hacking Minesweeper</h1>
            <h3>July 2021</h3>
        </div>
        <div class="paragraph">
            <p>
                I recently decided that I wanted to start learning a bit about game hacking to become a better reverse engineer, and figured, what better target than the classic minesweeper game? This is the first game I ever reversed, so my process was definitely not the most efficient, but after about 5 hours I accomplished the 2 goals I set for myself when starting this:<br><br>
                1. Guaranteed Win<br>
                2. Print out all bombs at game start 
            </p>
            <img src="../imgs/game/minesweeper/logo.webp" width="200" height="200" alt="">
        </div>
    </div>
</div>
<br><br><br><br><br><br>
