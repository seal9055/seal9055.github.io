<head> 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5X8D3297QB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5X8D3297QB');
</script>
</head>
<div class="page-header">
    <div class="page-header-inner">
        <div class="page-header-inner2">
            <h1>Exploitation</h1>
            <h2>December 2021</h2>
        </div>
    </div>
</div>
<H3>Introduction</H3>
<div class="paragraph">
    <p>
        This is the fifth part of a series on the Chrome browser and its javascript engine V8. After having learnt about all the major parts of the V8 engine in the previous parts, we can now finally start talking about actual exploitation. We will start by talking about various mitigations used by Chrome to make exploits more difficult. Next we will discuss what type of vulnerabilities we can expect in the browser and the basic building blocks that you can expect to see in most exploits.
        <br>
    </p>
</div>
<H3>Mitigations</H3>
<div class="paragraph">
    <p>
        As mentioned earlier, we will be start by some of the mitigations employed by Chrome. This has evolved a lot throughout the past years with Chrome becomming more and more secure every year. Their main goal in designing the browser is defense in depth. This defense philosophy is based upon layering multiple defenses on top of each other to avoid single points of failure. Chrome's sandbox is the best example of this being used effectively. While there are many more mitigations and security features aimed at securing various different parts of the browser, let's quickly cover some of the most relevant one's.<br><br>
        
        <strong>Standard mitigations</strong><br>
        Chrome uses many of the industry standard mitigations such as ASLR, DEP, JIT Hardening, and SafeSEH (Windows only), however, due to the massive attack surface presented by a modern browsers, bypasses for these mitigations are oftentimes possible which leads to many of the mitigations mentioned below.<br><br>

        <strong>Partition Alloc</strong><br>
        Chrome's memory allocator, replaces malloc()/new(). It supports multiple independent partitions, which helps combat some memory corruption vulnerabilities. Buffer overflows in strings for example are mitigated by placing strings in a different memory partition of the heap than other objects. This mitigation is not perfect since each partition still has many objects that have the potential to influence each other given bugs, but it can help mitigate certain bug-classes. Partitionalloc also makes use of guard pages to protect certain especially vulnerable objects. Some of these such as free-lists are also encoded & shadowed to make exploitation of standard heap vulnberabilities impractical. Additionally this custom heap implementation allows for a mitigation called StarScan, which consistently scans the heap and quarantines unused chunks so they cannot be used for exploits relying on a use-after-free vulnerability.<br><br>

        <strong>Stack Guard Pages</strong><br>
        Chrome also uses guard pages for its stack, which makes traditional exploits such as buffer overflows unexploitable unless they manage to write beyond the guard page without actually hitting the guard page itself.<br><br>

        <strong>W^X JIT</strong><br>
        Turbofan requires executeable pages of memory to place its generated code in. The W^X mitigation sets these pages as non-writeable as soon as the machine code is placed in them so an attacker can no longer use them for their exploit. This however is only true for standard JS code. WASM (web-assembly) also uses a JIT compiler, however, its JIT pages are not protected by default so they can still be used for an attacker to place shellcode in.<br><br>

        <strong>Site Isolation</strong><br>
        Site Isolation places every individual iframe into their very own renderer process with their own individual sandbox that limits what the process can do. This makes it much more difficult for a malicious website to steal data from other sites, even if it can break some of the rules in its own process. This mitigation has been very effective in preventing exploits such as Same Origin Policy bypasses using iframes.<br><br>

        <strong>Sandbox</strong><br>
        The sandbox is probably Chrome's most effective mitigation. It leverages OS-provided security so that code execution within a chrome process does not grant the attacker control over any other chrome processes or the underlying OS. The sandbox implements inter-process-communication (IPC) between the individual processes to enable the processes to communicate. This also grants the sandbox the ability to completely filter these and take care of any potential security holes from an exploited renderer process. This sandbox means that even once an attacker successfuly exploits the Chrome Renderer process, they still need an additional vulnerability in the sandbox to get actual code execution. The main attack surface of this sandbox generally lies in the IPC channels between the sandboxed process and the privileged browser process.<br><br>

        <strong>Rust</strong><br>
        Since 2020 the chrome dev team has been experimenting with Rust and its interoperability with c++ in the chrome browser, however, this is more of a background investigation and has not been widely implemented in chrome yet. If it would actually become widely adopted at some point, it would make the browser a lot more secure as a whole since it has the potential to eliminate many memory corruption vulnerabilities prevalent in the current c++ code-base.<br><br>

        These are far from all of the mitigations enabled in the browser, but they are probably the most relevant for the type of memory corruption exploits covered in this series.
        <br><br>
    </p>
</div>
<H3>Vulnerability Patterns</H3>
<div class="paragraph">
    <p>
        <br>
        Let's talk a little about where we might actually be able to find vulnerabilities. Jumping into the source code and looking for buffer overflows or heap vulnerabilities such as double free's or use after free's will not result in much success. Such classic vulnerabilities have been almost entirely mitigated at this point.<br><br>

        As you may have noticed by now, the V8 javascript engine is basically a giant complex interpreter + compiler. This means that if we can manipulate some of the information the V8 engine uses to execute JS code, we can make V8 display unintended behavior. V8's JIT compiler, Turbofan, presents a very large attack surface, especially when it comes to its speculative optimizations.<br><br>

        Let's say Turbofan decides to just-in-time compile a function using type information from the interpreter, and optimizes it for one specific type. What happens when the function suddenly gets called with different function arguments? Well optimally we would like to recognize that and trigger the deoptimization routine accordingly, but what if this routine is not triggered due to some bug in V8 and instead code just keeps executing with V8 expecting the wrong type.<br><br>

        Let's look at the example below. In this simple example the V8 binary was patched to remove all deoptimization routines. This is obviously a very unrealistic example, but it will do just fine to demonstrate a simple example.
        <br><br>
    </p>
</div>
<div class="highlight" style="background: #002b36"><pre style="line-height: 125%;"><span></span><span style="color: #2aa198">function</span> <span style="color: #839496">poc(a)</span> <span style="color: #839496">{</span>
    <span style="color: #859900">for</span> <span style="color: #839496">(</span><span style="color: #2aa198">let</span> <span style="color: #839496">i</span> <span style="color: #586e75">=</span> <span style="color: #2aa198">0</span><span style="color: #839496">;</span> <span style="color: #839496">i</span> <span style="color: #586e75">&lt;</span> <span style="color: #2aa198">1</span><span style="color: #839496">;</span> <span style="color: #839496">i</span><span style="color: #586e75">++</span><span style="color: #839496">)</span> <span style="color: #839496">{</span>
        <span style="color: #839496">i</span> <span style="color: #586e75">+=</span> <span style="color: #2aa198">2</span><span style="color: #839496">;</span>
    <span style="color: #839496">}</span>
    <span style="color: #859900">return</span> <span style="color: #839496">a[</span><span style="color: #2aa198">0</span><span style="color: #839496">];</span>
<span style="color: #839496">}</span>

<span style="color: #2aa198">let</span> <span style="color: #839496">o</span> <span style="color: #586e75">=</span> <span style="color: #839496">{</span> <span style="color: #839496">x</span><span style="color: #586e75">:</span> <span style="color: #2aa198">1</span> <span style="color: #839496">};</span>
<span style="color: #2aa198">let</span> <span style="color: #839496">a</span> <span style="color: #586e75">=</span> <span style="color: #839496">[</span><span style="color: #2aa198">1.1</span><span style="color: #839496">,</span> <span style="color: #2aa198">2.2</span><span style="color: #839496">,</span> <span style="color: #2aa198">3.3</span><span style="color: #839496">];</span>
<span style="color: #2aa198">let</span> <span style="color: #839496">b</span> <span style="color: #586e75">=</span> <span style="color: #839496">[</span> <span style="color: #839496">o,</span> <span style="color: #839496">o</span> <span style="color: #839496">];</span>

<span style="color: #859900">for</span> <span style="color: #839496">(</span><span style="color: #2aa198">let</span> <span style="color: #839496">i</span> <span style="color: #586e75">=</span> <span style="color: #2aa198">0</span><span style="color: #839496">;</span> <span style="color: #839496">i</span> <span style="color: #586e75">&lt;</span> <span style="color: #2aa198">1000000</span><span style="color: #839496">;</span> <span style="color: #586e75">++</span><span style="color: #839496">i)</span> <span style="color: #839496">{</span>
    <span style="color: #839496">poc(a);</span>
<span style="color: #839496">}</span>

<span style="color: #839496">console.log(poc(b));</span>
</pre></div>
<div class="paragraph">
    <p>
        The above code calls the poc function using an array of float values 1 million times in a row. This triggers Turbofan which produces machine code that is optimized for an array of float values. You can ignore the small seemingly useless loop in the poc function. It exists only to make the function a little more complex to prevent inlining which would make this example impractical.<br><br>

        So what happens when the function attempts to return a[0]? Well, for a float array it will first dereference the elements-pointer at object-base + 8, and then proceed to return the value of the element located at array[0]. Due to the format of the elements memory region, this value is located at elements+12. The overall retrieval process would be something like this: <i>return *(*(object-base+8)+12)</i>. You can review the 3rd part on V8 memory management if you need a reminder about how objects are laid out in memory. <br><br>

        We can verify this using Turbolizer. (I used a non-vulnerable V8 version to demonstrate where the CheckMaps would generally be located to verify that we are in fact dealing with an array of floats.)
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/exploitation/jit1.png" alt="">
</div>
<div class="paragraph">
    <p>
        As you can see above, the parameter is first verified using CheckMaps before being passed to a set of LoadField to retrieve the values. Finally LoadElement is used with the type set to Float64 to return the direct value. This seems pretty efficient compared to what you might find if you instead traced interpreter execution (You could do this using the <i>--print-bytecode</i> flag). However what if the call to CheckMaps was removed and we suddenly called the function using an array of objects? Suddenly the field in memory at <i>*(*(object-base+8)+12)</i> would be a pointer to an object instead of the actual float value. V8 however would still treat it as a Float64 value and return this value directly to the user. Suddenly we have an address leak that can be used to bypass ASLR!<br><br>

        This address-leak is printed out as a floating-point number, however, rest assured that this is in fact a valid address. This is because V8 is still expecting a float value for the call to console.log. We will later cover some helper functions that we can use to convert the float values to Number arrays so we can properly work with the values so don't worry about it yet. If you wish to replicate this example, I used picoctf's horsepower challenge which includes a patch to add this exact vulnerability.
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/exploitation/jit2.png" alt="">
</div>
<div class="paragraph">
    <p>
        We just managed to leak out an address thus giving us the potential to bypass ASLR. The above sample vulnerability is a lot simpler than any bug you would actually find in V8, so let's talk about a few more realistic scenarios of how such a bug might occur before covering how to actually exploit them.<br><br>

        As you know, Turbofan uses various complex optimization passes. One such pass is redundancy elimination. This optimization removes extra checks if it manages to determin that no side effects can occur between the last check on an object and its next usage. An example code snippet in which redundancy optimization might occur is: <i>let a = obj.x + obj.y;</i>. In this example Turbofan might recognize that there is no possibility for the object to change between the retrieval of obj.x and obj.y and thus only validate the map once. However, what if Turbofan missed a side effect. For the above example, if obj was global, a race condition might be able to manipulate the object's map between the retrieval of obj.x and obj.y.<br><br>

        The above is a very simple example for which it is relatively easy to determine if any side effects are possible. Redundancy elimination also acts on much more complicated code samples though, oftentimes having to determine if entire functions might have side effects on an object. If a side effect is missed, this can lead to an exploitable bug.<br><br>

        <i>Operator::kNoWrite</i> is a flag associated with operations to indicate that they are not supposed to have side effects. When looking for vulnerabilities in V8, a common approach might be to look for operations with this flag, and then attempt to find a case where it might actually have some side effects after all.<br><br>

        Most optimization phases in Turbofan can lead to some type of vulnerability if buggy code is found. The lowering phase might for example create integer over/underflows during machine code generation. Incorrect bounds-checks during the range analysis of the typer phase could lead overflow bugs. If the range analysis for example determines that an array's maximum possible size could be 10, an array of size 10+ might be allocated. At this point since the range analysis determined that the array will not have a larger size, there may not be any size checks, leading to a possible out of bounds read/write. Very similar bugs can just as easily occur in other optimization phases.<br><br>

        At this point a good way to learn more about various vulnerability patterns is to just start looking through various Chrome CVE's and attempt to understand what exactly caused them to occur.
        <br><br>
    </p>
</div>
<H3>Exploit Building Blocks</H3>
<div class="paragraph">
    <p>
        <strong>Shellcode</strong><br>
        Since we intend to make use of shellcode, we first need a page in memory that is both writeable and executeable. As discussed earlier, almost everything in the V8 address-space has W^X enabled. Pages created using web-assembly however are both writeable and executeable. When creating a wasm function as demonstrated below, a RWX page is created in memory. This address is then stored at wasm_instance + offset and can be leaked out using some of the exploit primitives we discuss below. After leaking out the address of this page, we use our arbitrary write primitive (also discussed below) to write shellcode to this area in memory and thus execute our own code.
        <br><br>
    </p>
</div>
<div class="highlight" style="background: #002b36"><pre style="line-height: 125%;"><span></span><span style="color: #2aa198">let</span> <span style="color: #839496">wasm_code</span> <span style="color: #586e75">=</span> <span style="color: #859900">new</span> <span style="color: #268bd2">Uint8Array</span><span style="color: #839496">([</span><span style="color: #2aa198">0</span><span style="color: #839496">,</span><span style="color: #2aa198">97</span><span style="color: #839496">,</span><span style="color: #2aa198">115</span><span style="color: #839496">,</span><span style="color: #2aa198">109</span><span style="color: #839496">,</span><span style="color: #2aa198">1</span><span style="color: #839496">,</span><span style="color: #2aa198">0</span><span style="color: #839496">,</span><span style="color: #2aa198">0</span><span style="color: #839496">,</span><span style="color: #2aa198">0</span><span style="color: #839496">,</span><span style="color: #2aa198">1</span><span style="color: #839496">,...]);</span>
<span style="color: #2aa198">let</span> <span style="color: #839496">wasm_module</span> <span style="color: #586e75">=</span> <span style="color: #859900">new</span> <span style="color: #839496">WebAssembly.Module(wasm_code);</span>
<span style="color: #2aa198">let</span> <span style="color: #839496">wasm_instance</span> <span style="color: #586e75">=</span> <span style="color: #859900">new</span> <span style="color: #839496">WebAssembly.Instance(wasm_module);</span>
<span style="color: #2aa198">let</span> <span style="color: #839496">pwn</span> <span style="color: #586e75">=</span> <span style="color: #839496">wasm_instance.exports.main;</span>
</pre></div>
<div class="paragraph">
    <p>
        <strong>ftoi & itof</strong><br>
        These are 2 very useful helper functions that we will use to convert values from floats to integers and integers to floats. The first helper function, ftoi, takes a value of type float and converts it to a BigInt (large 64-bit integer) value, this will be helpful to convert the retrieved float values into numbers that we can actually work with. The second helper function, itof, accepts a BigInt value as its argument and converts it to a float. This function will be important when trying to write values into memory.<br><br>

        An example of how these 2 helper functions might look like is shown below.
        <br><br>
    </p>
</div>
<div class="highlight" style="background: #002b36"><pre style="line-height: 125%;"><span></span><span style="color: #2aa198">var</span> <span style="color: #839496">f64_buf</span> <span style="color: #586e75">=</span> <span style="color: #859900">new</span> <span style="color: #268bd2">Float64Array</span><span style="color: #839496">(buf);</span>
<span style="color: #2aa198">var</span> <span style="color: #839496">u32_buf</span> <span style="color: #586e75">=</span> <span style="color: #859900">new</span> <span style="color: #268bd2">Uint32Array</span><span style="color: #839496">(buf);</span>

<span style="color: #2aa198">function</span> <span style="color: #839496">ftoi(val)</span> <span style="color: #839496">{</span> 
    <span style="color: #839496">f64_buf[</span><span style="color: #2aa198">0</span><span style="color: #839496">]</span> <span style="color: #586e75">=</span> <span style="color: #839496">val;</span>
    <span style="color: #859900">return</span> <span style="color: #268bd2">BigInt</span><span style="color: #839496">(u32_buf[</span><span style="color: #2aa198">0</span><span style="color: #839496">])</span> <span style="color: #586e75">+</span> <span style="color: #839496">(</span><span style="color: #268bd2">BigInt</span><span style="color: #839496">(u32_buf[</span><span style="color: #2aa198">1</span><span style="color: #839496">])</span> <span style="color: #586e75">&lt;&lt;</span> <span style="color: #2aa198">32n</span><span style="color: #839496">);</span> <span style="color: #586e75; font-style: italic">// Watch for little endianness</span>
<span style="color: #839496">}</span>

<span style="color: #2aa198">function</span> <span style="color: #839496">itof(val)</span> <span style="color: #839496">{</span> 
    <span style="color: #839496">u32_buf[</span><span style="color: #2aa198">0</span><span style="color: #839496">]</span> <span style="color: #586e75">=</span> <span style="color: #268bd2">Number</span><span style="color: #839496">(val</span> <span style="color: #586e75">&amp;</span> <span style="color: #2aa198">0xffffffffn</span><span style="color: #839496">);</span>
    <span style="color: #839496">u32_buf[</span><span style="color: #2aa198">1</span><span style="color: #839496">]</span> <span style="color: #586e75">=</span> <span style="color: #268bd2">Number</span><span style="color: #839496">(val</span> <span style="color: #586e75">&gt;&gt;</span> <span style="color: #2aa198">32n</span><span style="color: #839496">);</span>
    <span style="color: #859900">return</span> <span style="color: #839496">f64_buf[</span><span style="color: #2aa198">0</span><span style="color: #839496">];</span>
<span style="color: #839496">}</span>
</pre></div>
<div class="paragraph">
    <p>
        <strong>addrof & fakeobj</strong><br>
        We actually already briefly talked about the addrof primitive when we talked about the address leak earlier. The goal of the addrof function is to take in an arbitrary object and return its address. Such a primitive is necessary to bypass the ASLR mitigation that randomizes the V8 address-spaces. This is usually accomplished by a type-confusion. Unlike the above 2 helper functions, these primitives require an actual bug, and thus their exact implementation depends on the actual bug you're attempting to exploit. Pseudo-code of how this might look like however is shown below.
        <br><br>
    </p>
</div>
<div class="highlight" style="background: #002b36"><pre style="line-height: 125%;"><span></span><span style="color: #2aa198">function</span> <span style="color: #839496">addrof(obj)</span> <span style="color: #839496">{</span>
    <span style="color: #586e75; font-style: italic">// Insert the object which's address we want to leak into an object array</span>
    <span style="color: #839496">obj_arr[</span><span style="color: #2aa198">0</span><span style="color: #839496">]</span> <span style="color: #586e75">=</span> <span style="color: #839496">obj;</span>

    <span style="color: #586e75; font-style: italic">// Change the obj array's map to the float array's map</span>
    <span style="color: #839496">obj_arr_map</span> <span style="color: #586e75">=</span> <span style="color: #839496">float_arr_map;</span>

    <span style="color: #586e75; font-style: italic">// Get the address by accessing an index of the object array that is now interpreted as a float array due to the map change</span>
    <span style="color: #2aa198">let</span> <span style="color: #839496">addr</span> <span style="color: #586e75">=</span> <span style="color: #839496">obj_arr[</span><span style="color: #2aa198">0</span><span style="color: #839496">];</span>

    <span style="color: #586e75; font-style: italic">// Return the address as a BigInt</span>
    <span style="color: #859900">return</span> <span style="color: #839496">ftoi(addr);</span>
<span style="color: #839496">}</span>
</pre></div>
<div class="paragraph">
    <p>
        In the above example, we overwrite the map of a float array with the map of an object array using some V8 bug. When attempting to access this object, the float map will treat the elements as float values and thus return the value instead of an address pointer. Carefully crafted, this primitive can be generalized, thus leading to the addrof primitive.<br><br>

        Moving on to the fakeobj primitive, this is in fact very similar to the above example. We overwrite the map of an object array with the map of a float array, thus giving us the ability to directly manipulate pointers in V8's memory space. This primitive can then later be used place fake objects anywhere in memory, thus giving us the ability to arbitrarily read/write to memory.<br><br>

        Once we have these 2 primitives working, the combination of the addrof primitive to leak addresses, and fakeobj primitive to create fake objects can be used to craft our next, more powerful primitives.<br><br>

        <strong>arbread & arbwrite</strong><br>
        The purposes of these to primitives is to gain arbitrary read and write access throughout the processes address space. This will enable us to execute our own code by writing shellcode into memory.<br><br>

        Let's start with the arbitrary read. To perform this we could for example create a float array. By setting the 0th index of this array to a float array's map, we can place a fake-object on top of this array. The float array's second index would then be treated as the fake object's elements pointer. It could then be used to perform reads at arbitrary addresses by editing the element pointer using the backing float array.<br><br>

        The arbitrary write works very similar to the above arbitrary read. Just instead of reading an arbitrary address using the underlying float array, we can write to an address.<br><br>

        There is another technique that can be used to craft these 2 primitives using ArrayBuffer objects. If you are curious as to how these work, I have a detailed explanation in the browser exploitation ctf-writeup I linked below at the end of this post.
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/exploitation/calc.png" alt="">
</div>
<div class="paragraph">
    <p>
        Browser's are incredibly complex targets, and there is much more to learn when it comes to effectively hacking them, however, I hope that this series gave you a strong introduction into how Browsers function and a little insight into exploiting bugs in the Chrome browser. If you want to see how a full exploit looks or how the ArrayBuffer arb read/writes work, take a look at one of my ctf-writeups, exploiting a relatively simple V8 bug: <a href=https://seal9055.com/ctf-writeups/browser_exploitation/download_horsepower/>Download Horsepower/</a>.<br><br>

        Going from here, you should be able to attempt some browser-based ctf challenges of your own, and replicate some CVE's to further develop your exploit development skills in the realm of browsers. If you have any questions, feel free to reach out to me over twitter or discord and I'll be happy to help.
        <br><br><br><br><br><br>
    </p>
</div>
<script>
    try {
        pageOpenedDirectly;
    } catch (e) {
        var loc = window.location.pathname;
        var dir = loc.substring(0, loc.lastIndexOf('/'));
        dir = dir.split("/")[dir.split("/").length - 1];
        let currentLoc = location.href;
        let currentFile = location.href.split("/").slice(-1);
        currentLoc = currentLoc.replace(currentFile, "");
        currentLoc = currentLoc.replace(dir+"/", "");
        currentLoc = currentLoc.slice(0, -1);
        if (currentFile[0].indexOf(".html") !== -1) currentFile = currentFile[0].slice(0, -5);
        window.location = currentLoc + "?p=" + currentFile + "&d=" + dir;
    }
    </script>